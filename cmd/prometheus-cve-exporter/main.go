package main

import (
	"context"
	"crypto/tls"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"zops.top/prometheus-cve-exporter/config"
	"zops.top/prometheus-cve-exporter/internal/exporter"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

type UpdateMetricsFunc func(*config.Config)

type Server struct {
	cfg           *config.Config
	logger        *log.Logger
	mux           *http.ServeMux
	server        *http.Server
	updateMetrics UpdateMetricsFunc
}

func NewServer(cfg *config.Config, logger *log.Logger, updateMetrics UpdateMetricsFunc) *Server {
	return &Server{
		cfg:           cfg,
		logger:        logger,
		mux:           http.NewServeMux(),
		updateMetrics: updateMetrics,
	}
}

func (s *Server) SetupRouter() {
	s.mux.Handle("/metrics", promhttp.HandlerFor(
		prometheus.DefaultGatherer,
		promhttp.HandlerOpts{
			EnableOpenMetrics: true,
		},
	))

	s.mux.HandleFunc("/", s.homeHandler)
}

func (s *Server) homeHandler(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	fmt.Fprint(w, `<a href="/metrics">Go to metrics</a>`)
}

func (s *Server) Start() {
	s.server = &http.Server{
		Addr:         fmt.Sprintf(":%d", s.cfg.Port),
		Handler:      s.mux,
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  120 * time.Second,
	}

	if s.cfg.UseTLS {
		s.server.TLSConfig = &tls.Config{
			MinVersion:               tls.VersionTLS12,
			PreferServerCipherSuites: true,
		}
	}

	go func() {
		var err error
		s.logger.Printf("Starting server on :%d\n", s.cfg.Port)
		if s.cfg.UseTLS {
			s.logger.Println("TLS enabled")
			err = s.server.ListenAndServeTLS(s.cfg.TLSCert, s.cfg.TLSKey)
		} else {
			s.logger.Println("TLS disabled")
			err = s.server.ListenAndServe()
		}
		if err != nil && err != http.ErrServerClosed {
			s.logger.Fatalf("Could not listen on %d: %v\n", s.cfg.Port, err)
		}
	}()
}

func (s *Server) GracefulShutdown() {
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	sig := <-quit
	s.logger.Printf("Received signal: %v. Initiating shutdown...", sig)

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	s.server.SetKeepAlivesEnabled(false)
	if err := s.server.Shutdown(ctx); err != nil {
		s.logger.Fatalf("Server forced to shutdown: %v", err)
	}

	s.logger.Println("Server exiting")
}

func main() {
	logger := log.New(os.Stdout, "", log.LstdFlags)

	cfg, err := config.Load()
	if err != nil {
		logger.Fatalf("Failed to load configuration: %v", err)
	}

	server := NewServer(cfg, logger, exporter.UpdateMetrics)
	go server.updateMetrics(cfg)

	server.SetupRouter()
	server.Start()
	server.GracefulShutdown()
}
