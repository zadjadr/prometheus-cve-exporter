package config

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strings"
	"time"
)

const (
	defaultNVDFeedURL     = "https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-recent.json.gz"
	defaultUpdateInterval = 24 * time.Hour
	defaultPort           = 10250
	defaultSeverity       = "CRITICAL"
	defaultPackageFile    = ""
	defaultUseTLS         = false
	defaultTLSCert        = ""
	defaultTLSKey         = ""
)

type Config struct {
	NVDFeedURL     string        `json:"nvd_feed_url"`
	UpdateInterval time.Duration `json:"update_interval"`
	Port           int           `json:"port"`
	Severity       []string      `json:"severity"`
	PackageFile    string        `json:"package_file,omitempty"`
	UseTLS         bool          `json:"use_tls,omitempty"`
	TLSCert        string        `json:"tls_cert,omitempty"`
	TLSKey         string        `json:"tls_key,omitempty"`
}

type configHelper struct {
	NVDFeedURL     string   `json:"nvd_feed_url"`
	UpdateInterval string   `json:"update_interval"`
	Port           int      `json:"port"`
	Severity       []string `json:"severity"`
	PackageFile    string   `json:"package_file,omitempty"`
	TLSCert        string   `json:"tls_cert,omitempty"`
	TLSKey         string   `json:"tls_key,omitempty"`
}

func NewConfig() *Config {
	return &Config{
		NVDFeedURL:     defaultNVDFeedURL,
		UpdateInterval: defaultUpdateInterval,
		Port:           defaultPort,
		Severity:       []string{defaultSeverity},
		PackageFile:    defaultPackageFile,
		UseTLS:         defaultUseTLS,
		TLSCert:        defaultTLSCert,
		TLSKey:         defaultTLSKey,
	}
}

func Load() (*Config, error) {
	cfg := NewConfig()
	configFile := parseFlags(cfg)

	if configFile != "" {
		if err := loadConfigFile(cfg, configFile); err != nil {
			return nil, fmt.Errorf("error loading config file: %w", err)
		}
	}

	overrideWithEnv(cfg)

	if err := validateConfig(cfg); err != nil {
		return nil, err
	}

	if cfg.TLSCert != defaultTLSCert && cfg.TLSKey != defaultTLSKey {
		cfg.UseTLS = true
	}

	fmt.Print(prettyfyCfg(cfg))
	return cfg, nil
}

func parseFlags(cfg *Config) string {
	var configFile string
	flag.StringVar(&configFile, "config", "", "path to config file")

	flag.StringVar(&cfg.NVDFeedURL, "nvd-feed-url", defaultNVDFeedURL, "URL for the NVD feed")
	flag.DurationVar(&cfg.UpdateInterval, "update-interval", defaultUpdateInterval, "Update interval duration")
	flag.IntVar(&cfg.Port, "port", defaultPort, "Port to run the server on")
	flag.StringVar(&cfg.PackageFile, "package-file", defaultPackageFile, "Path to file containing packages and versions")
	flag.StringVar(&cfg.TLSCert, "tls-cert", defaultTLSCert, "Path to TLS certificate file")
	flag.StringVar(&cfg.TLSKey, "tls-key", defaultTLSKey, "Path to TLS key file")

	var severity string
	flag.StringVar(&severity, "severity", defaultSeverity, "Comma separated list of severity levels for vulnerabilities")
	flag.Parse()

	cfg.Severity = parseSeverity(severity)
	return configFile
}

func loadConfigFile(cfg *Config, filename string) error {
	file, err := os.ReadFile(filename)
	if err != nil {
		return fmt.Errorf("error reading config file: %w", err)
	}

	var helper configHelper
	if err := json.Unmarshal(file, &helper); err != nil {
		return fmt.Errorf("error parsing config file: %w", err)
	}

	cfg.NVDFeedURL = helper.NVDFeedURL
	cfg.Port = helper.Port
	cfg.Severity = toUppercase(helper.Severity)
	cfg.PackageFile = helper.PackageFile
	cfg.TLSCert = helper.TLSCert
	cfg.TLSKey = helper.TLSKey

	duration, err := time.ParseDuration(helper.UpdateInterval)
	if err != nil {
		return fmt.Errorf("error parsing update interval: %w", err)
	}
	cfg.UpdateInterval = duration

	return nil
}

func overrideWithEnv(cfg *Config) {
	envVars := map[string]func(string){
		"PCE_NVD_JSON_GZ_FEED_URL": func(value string) { cfg.NVDFeedURL = value },
		"PCE_UPDATE_INTERVAL": func(value string) {
			if duration, err := time.ParseDuration(value); err == nil {
				cfg.UpdateInterval = duration
			} else {
				fmt.Printf("Warning: invalid PCE_UPDATE_INTERVAL, using current value: %v\n", cfg.UpdateInterval)
			}
		},
		"PCE_PORT": func(value string) {
			if port, err := parseIntEnv(value); err == nil {
				cfg.Port = port
			} else {
				fmt.Printf("Warning: invalid PCE_PORT, using current value: %d\n", cfg.Port)
			}
		},
		"PCE_SEVERITY":     func(value string) { cfg.Severity = parseSeverity(value) },
		"PCE_PACKAGE_FILE": func(value string) { cfg.PackageFile = value },
		"PCE_TLS_CERT":     func(value string) { cfg.TLSCert = value },
		"PCE_TLS_KEY":      func(value string) { cfg.TLSKey = value },
	}

	for envVar, action := range envVars {
		if value := os.Getenv(envVar); value != "" {
			action(value)
		}
	}
}

func validateConfig(cfg *Config) error {
	if cfg.PackageFile != "" {
		if _, err := os.Stat(cfg.PackageFile); os.IsNotExist(err) {
			return fmt.Errorf("the file %s does not exist", cfg.PackageFile)
		}
	}
	if cfg.TLSCert != defaultTLSCert || cfg.TLSKey != defaultTLSKey {
		if _, err := os.Stat(cfg.TLSCert); os.IsNotExist(err) {
			return fmt.Errorf("the TLS certificate file %s does not exist", cfg.TLSCert)
		}
		if _, err := os.Stat(cfg.TLSKey); os.IsNotExist(err) {
			return fmt.Errorf("the TLS key file %s does not exist", cfg.TLSKey)
		}
	}
	return nil
}

func toUppercase(input []string) []string {
	output := make([]string, len(input))

	for i, s := range input {
		output[i] = strings.ToUpper(s)
	}

	return output
}

func parseSeverity(severity string) []string {
	return toUppercase(strings.Split(severity, ","))
}

func parseIntEnv(value string) (int, error) {
	var result int
	_, err := fmt.Sscan(value, &result)
	return result, err
}

func parseBoolEnv(value string) bool {
	switch value {
	case "true":
		return true
	default:
		return false
	}
}

func prettyfyCfg(cfg *Config) string {
	var output strings.Builder

	output.WriteString("Current configuration:\n")
	output.WriteString(fmt.Sprintf("    NVD Feed URL: %s\n", cfg.NVDFeedURL))
	output.WriteString(fmt.Sprintf("    Update Interval: %s\n", cfg.UpdateInterval.String()))
	output.WriteString(fmt.Sprintf("    Severity Levels: %v\n", cfg.Severity))
	output.WriteString(fmt.Sprintf("    Port: %d\n", cfg.Port))
	if cfg.PackageFile != "" {
		output.WriteString(fmt.Sprintf("    Package file: %s\n", cfg.PackageFile))
	}
	output.WriteString(fmt.Sprintf("    Use TLS: %v\n", cfg.UseTLS))
	if cfg.UseTLS {
		output.WriteString(fmt.Sprintf("    TLS Certificate: %s\n", cfg.TLSCert))
		output.WriteString(fmt.Sprintf("    TLS Key: %s\n", cfg.TLSKey))
	}

	return output.String()
}
