package exporter

import (
	"bufio"
	"compress/gzip"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"time"

	"zops.top/prometheus-cve-exporter/config"
	"zops.top/prometheus-cve-exporter/internal/metrics"
	"zops.top/prometheus-cve-exporter/internal/models"
)

type PackageManager struct {
	Command string
	Args    []string
}

var packageManagers = []PackageManager{
	{"dpkg-query", []string{"-W", "-f", "${Package} ${Version}\n"}},
	{"pacman", []string{"-Q"}},
	{"rpm", []string{"-qa", "--qf", "%{NAME} %{VERSION}\n"}},
	{"apk", []string{"info", "-v"}},
}

func GetInstalledPackages(packageFile string) (map[string]string, error) {
	var output []byte
	var err error

	if packageFile == "" {
		output, err = parseInstalledPackagesFromPackageManager()
	} else {
		output, err = os.ReadFile(packageFile)
	}

	if err != nil {
		return nil, fmt.Errorf("error getting installed packages: %w", err)
	}

	return parsePackagesOutput(output), nil
}

func parseInstalledPackagesFromPackageManager() ([]byte, error) {
	for _, pm := range packageManagers {
		if _, err := exec.LookPath(pm.Command); err == nil {
			output, err := exec.Command(pm.Command, pm.Args...).Output()
			if err != nil {
				return nil, fmt.Errorf("error executing package manager command: %w", err)
			}
			return output, nil
		}
	}
	return nil, fmt.Errorf("no suitable package manager found")
}

func parsePackagesOutput(output []byte) map[string]string {
	packages := make(map[string]string)
	scanner := bufio.NewScanner(strings.NewReader(string(output)))

	for scanner.Scan() {
		line := scanner.Text()
		parts := strings.Fields(line)
		if len(parts) >= 2 {
			packages[parts[0]] = parts[1]
		}
	}

	return packages
}

func fetchNVDFeed(url string) (*models.NVDFeed, error) {
	// Fetch the URL
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("error downloading NVD feed: %w", err)
	}
	defer resp.Body.Close()

	// Check HTTP status
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	// Prepare reader based on the content type
	var reader io.ReadCloser = resp.Body
	if strings.HasSuffix(url, ".gz") {
		gzReader, err := gzip.NewReader(reader)
		if err != nil {
			return nil, fmt.Errorf("error creating gzip reader: %w", err)
		}
		defer gzReader.Close()
		reader = gzReader
	}

	// Decode JSON feed
	var feed models.NVDFeed
	if err := json.NewDecoder(reader).Decode(&feed); err != nil {
		return nil, fmt.Errorf("error decoding JSON: %w", err)
	}

	return &feed, nil
}

func checkVulnerabilities(packages map[string]string, feed *models.NVDFeed, severity []string) {
	metrics.ResetVulnerablePackagesGauge()
	totalVulnerabilities := 0

	for _, item := range feed.CVEItems {
		if item.Impact.BaseMetricV3 != nil && contains(severity, strings.ToUpper(item.Impact.BaseMetricV3.CVSSV3.BaseSeverity)) {
			totalVulnerabilities += checkConfigurationNode(
				packages, item.CVE.CVEDataMeta.ID, strings.ToUpper(item.Impact.BaseMetricV3.CVSSV3.BaseSeverity), item.Configurations.Nodes,
			)
		}
	}

	metrics.SetTotalVulnerabilities(float64(totalVulnerabilities))
	metrics.SetLastUpdateTime()
}

func checkConfigurationNode(packages map[string]string, cveID string, impact string, nodes []models.Node) int {
	vulnerableCount := 0
	for _, node := range nodes {
		for _, cpeMatch := range node.CPEMatch {
			if cpeMatch.Vulnerable {
				parts := strings.Split(cpeMatch.CPE23Uri, ":")
				if len(parts) > 4 {
					packageName := parts[4]
					if installedVersion, ok := packages[packageName]; ok {
						if isVersionVulnerable(installedVersion, cpeMatch) {
							metrics.UpdateVulnerablePackage(packageName, installedVersion, cveID, impact, 1)
							vulnerableCount++
						}
					}
				}
			}
		}
		vulnerableCount += checkConfigurationNode(packages, cveID, impact, node.Children)
	}
	return vulnerableCount
}

func isVersionVulnerable(installedVersion string, cpeMatch models.CPEMatch) bool {
	if (cpeMatch.VersionStartExcluding != "" && installedVersion <= cpeMatch.VersionStartExcluding) ||
		(cpeMatch.VersionStartIncluding != "" && installedVersion < cpeMatch.VersionStartIncluding) ||
		(cpeMatch.VersionEndExcluding != "" && installedVersion >= cpeMatch.VersionEndExcluding) ||
		(cpeMatch.VersionEndIncluding != "" && installedVersion > cpeMatch.VersionEndIncluding) {
		return false
	}

	return true
}

func UpdateMetrics(cfg *config.Config) {
	for {
		packages, err := GetInstalledPackages(cfg.PackageFile)
		if err != nil {
			log.Printf("Error getting installed packages: %v", err)
			time.Sleep(5 * time.Minute)
			continue
		}

		feed, err := fetchNVDFeed(cfg.NVDFeedURL)
		if err != nil {
			log.Printf("Error fetching NVD feed: %v", err)
			time.Sleep(5 * time.Minute)
			continue
		}

		checkVulnerabilities(packages, feed, cfg.Severity)

		log.Println("Metrics updated successfully")
		time.Sleep(cfg.UpdateInterval)
	}
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}
