package exporter

import (
	"os"
	"reflect"
	"testing"

	"zops.top/prometheus-cve-exporter/internal/metrics"
	"zops.top/prometheus-cve-exporter/internal/models"
)

func TestGetInstalledPackages(t *testing.T) {
	// Create a temporary file with mock package data
	tmpfile, err := os.CreateTemp("", "packages")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tmpfile.Name())

	mockData := "package1 1.0.0\npackage2 2.0.0\n"
	if _, err := tmpfile.Write([]byte(mockData)); err != nil {
		t.Fatal(err)
	}
	if err := tmpfile.Close(); err != nil {
		t.Fatal(err)
	}

	packages, err := GetInstalledPackages(tmpfile.Name())
	if err != nil {
		t.Fatalf("GetInstalledPackages failed: %v", err)
	}

	expected := map[string]string{
		"package1": "1.0.0",
		"package2": "2.0.0",
	}

	if !reflect.DeepEqual(packages, expected) {
		t.Errorf("GetInstalledPackages() = %v, want %v", packages, expected)
	}
}

func TestParsePackagesOutput(t *testing.T) {
	input := []byte("package1 1.0.0\npackage2 2.0.0\npackage3 3.0.0")
	expected := map[string]string{
		"package1": "1.0.0",
		"package2": "2.0.0",
		"package3": "3.0.0",
	}

	result := parsePackagesOutput(input)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("parsePackagesOutput() = %v, want %v", result, expected)
	}
}

func TestCheckVulnerabilities(t *testing.T) {
	packages := map[string]string{
		"vulnerable_package": "1.0.0",
		"safe_package":       "2.0.0",
	}

	feed := &models.NVDFeed{
		CVEItems: []models.CVEItem{
			{
				CVE: models.CVE{
					CVEDataMeta: models.CVEDataMeta{
						ID: "CVE-2023-12345",
					},
				},
				Impact: models.Impact{
					BaseMetricV3: &models.BaseMetricV3{
						CVSSV3: models.CVSSV3{
							BaseSeverity: "HIGH",
						},
					},
				},
				Configurations: models.Configurations{
					Nodes: []models.Node{
						{
							CPEMatch: []models.CPEMatch{
								{
									Vulnerable: true,
									CPE23Uri:   "cpe:2.3:a:vendor:vulnerable_package:1.0.0:*:*:*:*:*:*:*",
								},
							},
						},
					},
				},
			},
		},
	}

	severity := []string{"HIGH"}

	// Reset metrics before test
	metrics.ResetVulnerablePackagesGauge()

	checkVulnerabilities(packages, feed, severity)

	// Here you would typically check the metrics.
	// For this example, we'll just verify that the function runs without panicking.
	// In a real test, you'd use a mocked metrics package to verify the correct metrics were set.
}

func TestIsVersionVulnerable(t *testing.T) {
	packages := map[string]string{
		"package1": "1.5.0",
	}

	tests := []struct {
		name     string
		cpeMatch models.CPEMatch
		want     bool
	}{
		{
			name: "Version in range",
			cpeMatch: models.CPEMatch{
				Vulnerable:            true,
				CPE23Uri:              "cpe:2.3:a:vendor:package1:*:*:*:*:*:*:*:*",
				VersionStartIncluding: "1.0.0",
				VersionEndExcluding:   "2.0.0",
			},
			want: true,
		},
		{
			name: "Version out of range",
			cpeMatch: models.CPEMatch{
				Vulnerable:            false,
				CPE23Uri:              "cpe:2.3:a:vendor:package1:*:*:*:*:*:*:*:*",
				VersionStartIncluding: "2.0.0",
				VersionEndExcluding:   "3.0.0",
			},
			want: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := isVersionVulnerable(packages["package1"], tt.cpeMatch); got != tt.want {
				t.Errorf("isVersionVulnerable() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestFetchNVDFeed(t *testing.T) {
	// This is a mock test. In a real scenario, you'd use a mock HTTP server.
	t.Skip("Skipping TestFetchNVDFeed as it requires network access")

	feed, err := fetchNVDFeed("https://example.com/feed.json")
	if err != nil {
		t.Fatalf("fetchNVDFeed() error = %v", err)
	}

	if feed == nil {
		t.Error("fetchNVDFeed() returned nil feed")
	}

	// Add more specific checks on the feed content if needed
}
