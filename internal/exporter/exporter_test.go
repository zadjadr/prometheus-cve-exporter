package exporter

import (
	"compress/gzip"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"os"
	"reflect"
	"testing"

	"github.com/prometheus/client_golang/prometheus"
	"zops.top/prometheus-cve-exporter/internal/metrics"
	"zops.top/prometheus-cve-exporter/internal/models"
)

func TestGetInstalledPackages(t *testing.T) {
	// Create a temporary file with mock package data
	tmpfile, err := os.CreateTemp("", "packages")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tmpfile.Name())

	mockData := "package1 1.0.0\npackage2 2.0.0\n"
	if _, err := tmpfile.Write([]byte(mockData)); err != nil {
		t.Fatal(err)
	}
	if err := tmpfile.Close(); err != nil {
		t.Fatal(err)
	}

	packages, err := GetInstalledPackages(tmpfile.Name())
	if err != nil {
		t.Fatalf("GetInstalledPackages failed: %v", err)
	}

	expected := map[string]string{
		"package1": "1.0.0",
		"package2": "2.0.0",
	}

	if !reflect.DeepEqual(packages, expected) {
		t.Errorf("GetInstalledPackages() = %v, want %v", packages, expected)
	}
}

func TestParsePackagesOutput(t *testing.T) {
	input := []byte("package1 1.0.0\npackage2 2.0.0\npackage3 3.0.0")
	expected := map[string]string{
		"package1": "1.0.0",
		"package2": "2.0.0",
		"package3": "3.0.0",
	}

	result := parsePackagesOutput(input)

	if !reflect.DeepEqual(result, expected) {
		t.Errorf("parsePackagesOutput() = %v, want %v", result, expected)
	}
}

func TestCheckVulnerabilities(t *testing.T) {
	testCases := []struct {
		name      string
		packages  map[string]string
		feed      *models.NVDFeed
		severity  []string
		expected  map[string]bool
		totalVuls float64
	}{
		{
			name: "Vulnerable and safe package",
			packages: map[string]string{
				"vulnerable_package": "1.0.0",
				"safe_package":       "2.0.0",
			},
			feed:     createTestFeed("1.0.5"),
			severity: []string{"HIGH"},
			expected: map[string]bool{
				"vulnerable_package": true,
				"safe_package":       false,
			},
			totalVuls: 1,
		},
		{
			name: "Both packages safe",
			packages: map[string]string{
				"vulnerable_package": "1.0.6",
				"safe_package":       "2.0.0",
			},
			feed:     createTestFeed("1.0.5"),
			severity: []string{"HIGH"},
			expected: map[string]bool{
				"vulnerable_package": false,
				"safe_package":       false,
			},
			totalVuls: 0,
		},
		{
			name: "Both packages in vulnerable version range",
			packages: map[string]string{
				"vulnerable_package": "1.0.0",
				"safe_package":       "1.0.4",
			},
			feed:     createTestFeed("1.0.5"),
			severity: []string{"HIGH"},
			expected: map[string]bool{
				"vulnerable_package": true,
				"safe_package":       false,
			},
			totalVuls: 1,
		},
		{
			name: "Ignore lower severity",
			packages: map[string]string{
				"vulnerable_package": "1.0.0",
			},
			feed:     createTestFeed("1.0.5"),
			severity: []string{"CRITICAL"},
			expected: map[string]bool{
				"vulnerable_package": false,
			},
			totalVuls: 0,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Reset metrics before each test case
			metrics.ResetVulnerablePackagesGauge()
			metrics.SetTotalVulnerabilities(0)

			checkVulnerabilities(tc.packages, tc.feed, tc.severity)

			metricsGathered, err := prometheus.DefaultGatherer.Gather()
			if err != nil {
				t.Fatalf("Failed to gather metrics: %v", err)
			}

			vulnerablePackagesFound := make(map[string]bool)
			var totalVulnerabilities float64
			var lastUpdateTime float64

			for _, metric := range metricsGathered {
				switch metric.GetName() {
				case "nvd_vulnerable_packages":
					for _, m := range metric.GetMetric() {
						labels := make(map[string]string)
						for _, label := range m.GetLabel() {
							labels[label.GetName()] = label.GetValue()
						}
						pkg := labels["package"]
						vulnerablePackagesFound[pkg] = true
						if m.GetGauge().GetValue() != 1 {
							t.Errorf("Expected vulnerable package metric to be 1 for %s, got %v", pkg, m.GetGauge().GetValue())
						}
					}
				case "nvd_total_vulnerabilities":
					totalVulnerabilities = metric.GetMetric()[0].GetGauge().GetValue()
				case "nvd_last_update_time":
					lastUpdateTime = metric.GetMetric()[0].GetGauge().GetValue()
				}
			}

			for pkg, expectedVulnerable := range tc.expected {
				if expectedVulnerable != vulnerablePackagesFound[pkg] {
					t.Errorf("Package %s: expected vulnerable = %v, got %v", pkg, expectedVulnerable, vulnerablePackagesFound[pkg])
				}
			}

			if totalVulnerabilities != tc.totalVuls {
				t.Errorf("Expected total vulnerabilities to be %v, got %v", tc.totalVuls, totalVulnerabilities)
			}

			if lastUpdateTime <= 0 {
				t.Errorf("Expected last update time to be > 0, got %v", lastUpdateTime)
			}
		})
	}
}

func createTestFeed(versionEndExcluding string) *models.NVDFeed {
	return &models.NVDFeed{
		CVEItems: []models.CVEItem{
			{
				CVE: models.CVE{
					CVEDataMeta: models.CVEDataMeta{
						ID: "CVE-2023-12345",
					},
				},
				Impact: models.Impact{
					BaseMetricV3: &models.BaseMetricV3{
						CVSSV3: models.CVSSV3{
							BaseSeverity: "HIGH",
						},
					},
				},
				Configurations: models.Configurations{
					Nodes: []models.Node{
						{
							CPEMatch: []models.CPEMatch{
								{
									Vulnerable:          true,
									CPE23Uri:            "cpe:2.3:a:vendor:vulnerable_package:1.0.0:*:*:*:*:*:*:*",
									VersionEndExcluding: versionEndExcluding,
								},
							},
						},
					},
				},
			},
		},
	}
}

func TestIsVersionVulnerable(t *testing.T) {
	packages := map[string]string{
		"package1": "1.5.0",
	}

	tests := []struct {
		name     string
		cpeMatch models.CPEMatch
		want     bool
	}{
		{
			name: "Version in range",
			cpeMatch: models.CPEMatch{
				Vulnerable:            true,
				CPE23Uri:              "cpe:2.3:a:vendor:package1:*:*:*:*:*:*:*:*",
				VersionStartIncluding: "1.0.0",
				VersionEndExcluding:   "2.0.0",
			},
			want: true,
		},
		{
			name: "Version out of range",
			cpeMatch: models.CPEMatch{
				Vulnerable:            false,
				CPE23Uri:              "cpe:2.3:a:vendor:package1:*:*:*:*:*:*:*:*",
				VersionStartIncluding: "2.0.0",
				VersionEndExcluding:   "3.0.0",
			},
			want: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := isVersionVulnerable(packages["package1"], tt.cpeMatch); got != tt.want {
				t.Errorf("isVersionVulnerable() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestFetchNVDFeed(t *testing.T) {
	tests := []struct {
		name           string
		cveItems       []models.CVEItem
		expectedID     string
		expectedLength int
		expectError    bool
	}{
		{
			name: "single item",
			cveItems: []models.CVEItem{
				{
					CVE: models.CVE{
						CVEDataMeta: models.CVEDataMeta{
							ID: "CVE-2023-TEST",
						},
					},
				},
			},
			expectedID:     "CVE-2023-TEST",
			expectedLength: 1,
			expectError:    false,
		},
		{
			name: "multiple items",
			cveItems: []models.CVEItem{
				{
					CVE: models.CVE{
						CVEDataMeta: models.CVEDataMeta{
							ID: "CVE-2023-TEST-1",
						},
					},
				},
				{
					CVE: models.CVE{
						CVEDataMeta: models.CVEDataMeta{
							ID: "CVE-2023-TEST-2",
						},
					},
				},
			},
			expectedID:     "CVE-2023-TEST-1",
			expectedLength: 2,
			expectError:    false,
		},
		{
			name:           "empty feed",
			cveItems:       []models.CVEItem{},
			expectedID:     "",
			expectedLength: 0,
			expectError:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a test server
			server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Encoding", "gzip")

				gzWriter := gzip.NewWriter(w)
				defer gzWriter.Close()

				// Create a JSON encoder and encode the data
				encoder := json.NewEncoder(gzWriter)
				err := encoder.Encode(models.NVDFeed{
					CVEItems: tt.cveItems,
				})
				if err != nil {
					t.Fatalf("Failed to encode JSON: %v", err)
				}

				// Ensure that the gzip writer is flushed
				if err := gzWriter.Close(); err != nil {
					t.Fatalf("Failed to close gzip writer: %v", err)
				}
			}))
			defer server.Close()

			feed, err := fetchNVDFeed(server.URL)
			if (err != nil) != tt.expectError {
				t.Fatalf("fetchNVDFeed() error = %v, wantErr %v", err, tt.expectError)
			}

			if feed == nil {
				if !tt.expectError {
					t.Error("fetchNVDFeed() returned nil feed")
				}
				return
			}

			if feed.CVEItems == nil {
				t.Error("feed.CVEItems is nil")
			} else if len(feed.CVEItems) != tt.expectedLength {
				t.Errorf("expected %d CVEItems, got %d", tt.expectedLength, len(feed.CVEItems))
			} else if len(feed.CVEItems) > 0 && feed.CVEItems[0].CVE.CVEDataMeta.ID != tt.expectedID {
				t.Errorf("expected CVE ID '%s', got %s", tt.expectedID, feed.CVEItems[0].CVE.CVEDataMeta.ID)
			}
		})
	}
}
